package com.playlab.bussolaagilimport androidx.compose.animation.core.LinearEasingimport androidx.compose.animation.core.animateFloatAsStateimport androidx.compose.animation.core.tweenimport androidx.compose.foundation.layout.*import androidx.compose.material.MaterialThemeimport androidx.compose.material.Textimport androidx.compose.runtime.Composableimport androidx.compose.runtime.getValueimport androidx.compose.runtime.mutableStateOfimport androidx.compose.runtime.rememberimport androidx.compose.ui.Alignmentimport androidx.compose.ui.Modifierimport androidx.compose.ui.draw.drawBehindimport androidx.compose.ui.geometry.Offsetimport androidx.compose.ui.geometry.Sizeimport androidx.compose.ui.graphics.Colorimport androidx.compose.ui.graphics.StrokeCapimport androidx.compose.ui.graphics.drawscope.DrawScopeimport androidx.compose.ui.graphics.drawscope.Strokeimport androidx.compose.ui.platform.testTagimport androidx.compose.ui.semantics.contentDescriptionimport androidx.compose.ui.semantics.semanticsimport androidx.compose.ui.tooling.preview.Previewimport androidx.compose.ui.unit.Dpimport androidx.compose.ui.unit.dpimport androidx.compose.ui.unit.spimport com.playlab.bussolaagil.ui.theme.BussolaAgilTheme@Composablefun MinimalCompass(    canvasSize: Dp = 300.dp,    color: Color = MaterialTheme.colors.onBackground,    degrees: Int = 360) {    val (lastRotation, setLastRotation) = remember { mutableStateOf(0) } // this keeps last rotation    var newRotation = lastRotation // newRotation will be updated in proper way    // last rotation converted to range [-359; 359]    val modLast = if (lastRotation > 0) lastRotation % 360 else 360 - (-lastRotation % 360)    // if modLast isn't equal rotation retrieved as function argument    // it means that newRotation has to be updated    if (modLast != degrees) {        // distance in degrees between modLast and rotation going backward        val backward = if (degrees > modLast) modLast + 360 - degrees else modLast - degrees        // distance in degrees between modLast and rotation going forward        val forward = if (degrees > modLast) degrees - modLast else 360 - modLast + degrees        // update newRotation so it will change rotation in the shortest way        newRotation = if (backward < forward) {            // backward rotation is shorter            lastRotation - backward        } else {            // forward rotation is shorter (or they are equal)            lastRotation + forward        }        setLastRotation(newRotation)    }    //negative value to rotate in opsite direction    // degrees - 270 to start the compass needle on top position    val rotation = -(newRotation - 270)    val angle by animateFloatAsState(        targetValue = rotation.toFloat(),        animationSpec = tween(            durationMillis = 300,            easing = LinearEasing        )    )    Box(modifier = Modifier            .size(canvasSize)            .semantics { contentDescription = "BoxContainer" }            .testTag("BoxContainer")            .drawBehind {                val componentSize = size / 1.25f                val componentSize2 = componentSize / 1.230f                compassBorder(                    componentSize = componentSize,                    color = color                )                compassNeedle(                    componentSize = componentSize2, startAngle = angle,                    color = color                )            },            contentAlignment = Alignment.Center        ){            Text(                text = "${degrees}º",                color = MaterialTheme.colors.onBackground,                fontSize = (canvasSize.value * .2f).toInt().sp            )        }    }fun DrawScope.compassNeedle(    componentSize: Size,    startAngle: Float,    color: Color){    drawArc(        size = componentSize,        color = color,        startAngle = startAngle,        sweepAngle = size.width * 0.0001f, //abertura do angulo        useCenter = false,        style = Stroke(            width = size.width * 0.06f,            cap = StrokeCap.Round        ),        topLeft = Offset(            //size é o canvasSize            //centralizando            x = (size.width - componentSize.width) / 2f,            y = (size.height - componentSize.height) / 2f        )    )}fun DrawScope.compassBorder(    componentSize: Size,    color: Color){    drawArc(        size = componentSize,        color = color,        startAngle = 0f,        sweepAngle = 360f, //abertura do angulo        useCenter = false,        style = Stroke(            width = size.width * 0.04f,            cap = StrokeCap.Round        ),        topLeft = Offset(            //size é o canvasSize            //centralizando            x = (size.width - componentSize.width) / 2f,            y = (size.height - componentSize.height) / 2f        )    )}@Composable@Preview(showBackground = true)fun CompassAnimationPreview() {    BussolaAgilTheme {        Column(            Modifier.fillMaxSize(),            horizontalAlignment = Alignment.CenterHorizontally,            verticalArrangement = Arrangement.Center        ) {            MinimalCompass(degrees = 90)        }    }}